\documentclass[a4paper,12pt]{article}

\usepackage{cmap}					% поиск в PDF
\usepackage[T2A]{fontenc}			% кодировка
\usepackage[utf8]{inputenc}			% кодировка исходного текста
\usepackage[english,russian]{babel}	% локализация и переносы
\usepackage{enumitem}  				% смена типа символя у enumerate
\usepackage{amsmath,amsfonts,amssymb,amsthm,epsfig,epstopdf,titling,url,array}
\usepackage{icomma} 				% "Умная" запятая: $0,2$ --- число, $0, 2$ --- перечисление
\usepackage{hyperref}				% кликабельные ссылки
\usepackage{soulutf8} 				% Модификаторы начертания
\usepackage{mathrsfs}				% теоремы
\usepackage{tabularx}				% X таблицы
\usepackage[backend=biber,
			bibencoding=utf8,
			bibstyle=numeric,
			sorting=none]			% цитирование в порядке появляения в тексте
		{biblatex}					% библиография
\usepackage{xparse} 				% для переопределения section* subsection* и пр., чтобы те появлялись в оглавлении
\usepackage[ruled,
			linesnumbered,
			vlined]
		{algorithm2e}				% красивые алгоритмы

\sloppy

\SetAlgorithmName{Алгоритм}{algo}{Список алгоритмов}
\SetKwInput{KwData}{Вход}
\SetKwInput{KwResult}{Выход}
\SetNlSty{textbf}{}{.}
\SetAlgoNlRelativeSize{0}
\SetKwIF{If}{ElseIf}{Else}{Если}{то}{иначе если}{иначе}{}

\addbibresource{sources.bib}

\theoremstyle{definition}
\newtheorem{defn}{Определение}


\let\oldsection\section
\makeatletter
\newcounter{@secnumdepth}
\RenewDocumentCommand{\section}{s o m}{%
	\IfBooleanTF{#1}
	{\setcounter{@secnumdepth}{\value{secnumdepth}}% Store secnumdepth
		\setcounter{secnumdepth}{0}% Print only up to \chapter numbers
		\oldsection{#3}% \section*
		\setcounter{secnumdepth}{\value{@secnumdepth}}}% Restore secnumdepth
	{\IfValueTF{#2}% \section
		{\oldsection[#2]{#3}}% \section[.]{..}
		{\oldsection{#3}}}% \section{..}
}
\makeatother

\author{Астраханцев Роман Геннадьевич}
\title{ОТЧЕТ о прохождении производственной практики}
\date{2021 г.}

\begin{document} % Конец преамбулы, начало текста.
	
	\thispagestyle{empty}
	\begin{center}
		Федеральное государственное автономное учреждение \\ высшего профессионального образования \\

		НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСИТЕТ \\ <<ВЫСШАЯ ШКОЛА ЭКОНОМИКИ>> \\
		\vspace{2ex}
		Образовательная программа «Компьютерная безопасность» \\
	\end{center}

	\begin{center}
		\vspace{15ex}
		\textbf{\so{ОТЧЁТ} \\ о прохождении производственной практики}
	\end{center}

	\vspace{10ex}

	\textbf{Студент:} Астраханцев Р.Г. СКБ 171 \underline{\hspace{5em} \vspace{-1mm}} 
		
	\textbf{Руководитель практики студента:} Нестеренко А.Ю. \underline{\hspace{5em} \vspace{-1mm}}  
		
	\textbf{Руководитель практики от НИУ ВШЭ:} Лось А.Б. \underline{\hspace{5em}  \vspace{-1mm}} 

	\vspace{8ex}
	\hspace{0.3\linewidth} \textbf{Практика пройдена с оценкой \underline{\hspace{3em} \vspace{-1mm}} }

	\vspace{5ex}
	\hspace{0.3\linewidth} \textbf{Дата \underline{\hspace{8em} \vspace{-1mm}} }

	\begin{center}
		
		\vfill
		\textbf{Москва, 2021}
	\end{center}
	
	\newpage
	\tableofcontents
	
	\newpage
	\section*{ВВЕДЕНИЕ}
	
	В рамках производственной практики, проходящей c 05.07.2021 по 31.07.2021 на кафедре компьютерной безопасности, перед студентом стояла задача описания принципиальной работы алгоритма пороговой схемы на основе подписи Эль-Гамаля. 
	
	В частности, студенту предстояло разобраться в задаче выработке валидной подписи несколькими участниками, которая бы проверялась одним публичным ключом. 
	
	В качестве дополнительных задач студенту предлагалось описать принципиальную схему выработки такой подписи с нулевым доверием между участниками, а также проанализировать полученную схему на предмет защищённости от раскрытия секретов злоумышленными участниками. 
	
	Пороговые схемы становятся популярным инструментом для создания межблокчейнового взаимодействия, поэтому задача построения защищённых пороговых схем становится всё более актуальной.
	
	\newpage
	\section{Задачи пороговой подписи }	
	
	С появлением смарт-контрaктов в блокчейн сетях появилась возможность принятия коллегиального решения разными сообществами. Наивной реализацией принятия такого решения было сочетание смарт-контрактов и мультиподписи. Процесс вынесения определённого решения заключался в создании смарт-контракта, который исполнялся тогда и только тогда, когда заданное количество собранных 
	\footnote{\emph{собранной} подпись считается тогда, когда член коллегии подпишет своей личной подписью определён-ное сообщение (например «Согласен с решением») и подаст полученный результат на вход смарт-контракту. Кроме того, смарт-контракт может реализовать механизм отзыва согласия, работающий по аналогичному признаку.}  
	электронных подписей будет аккумулятивно подано на вход смарт-контракту (возможно за несколько транзакций). 
	
	Такой подход имеет ряд недостатков:
	\begin{enumerate}[label=\arabic*)]
		\item На каждое новое решение требуется создание нового \emph{одноразового} смарт-контракта;
		\item Проверка коллегиального решения требует проверки \emph{каждой} поданной подписи;
		\item Сбор электронных подписей требует взаимодействия с блокчейном, что в свою очередь может быть долго/ресурсозатратно.
	\end{enumerate}	
	
	Для решения этих проблем было предложено использование технологии пороговых подписей. Идея заключается в том, чтобы вместо нескольких уникальных подписей от разных участников вырабатывать коллективную подпись, которую затем можно будет проверить коллективным публичным ключом. Пороговой такая схема называется из-за того, что в самой схеме задаётся минимальное количество участников (\emph{порог}), которое необходимо для выработки коллективной подписи произвольного сообщения.
	
	Подобная схема избавлена от всех описанных выше недостатков, однако имеет сложности в своей реализации. Так, например, как вырабатывать секреты участников децентрализовано, как гарантировать, что именно минимальное количество участников сможет подписать сообщение. Эти и другие вопросы рассмотрены в этой работе.
	
	Стоит отметить, что пороговые схемы находят своё применение не только в избавлении от генерации смарт-контрактов и увеличении производительности взаимодействия с блокчейном, но в любой задаче требующей выработки единого коллективного решения. К примеру, совет директоров той или иной ком-пании может выработать единую подпись от лица самой компании без раскрытия информации о том, кто был за это решение, в то время как использование мультиподписи раскрывает эту информацию. Ещё одним применением этой технологии в современных реалиях будет возможность осуществления эффективного взаимодействия между блокчейнами или шардами одного блокчейна.
	
	
	\section{Определение пороговой схемы}
	
	В настоящее время существуют разные схемы создания электронной подпи-си (ЭП). Пороговая схема \--- это некоторое расширение ЭП. Определим пороговую схему полуформально как в \cite{paper1}, чтобы не привязываться к конкретной реализации ЭП.
		
	\begin{defn}\label{def:Tscheme}
	\emph{$(t, n)$-пороговой схемой} для заданной схемы ЭП (т.е алгоритмов генерации ключа, подписи сообщений и верификации сообщений), включающей $n > 1$ участников $P_1, \dots, P_n$, способных осуществлять следующие протоколы:
	\begin{itemize}
		\item \label{def:Tkeygen} \emph{Протокол распределённой генерации ключа (РГК)}, в результате работы которого вырабатывается некоторый публичный ключ $pk$ и секретные доли $sk_i$ приватного ключа $sk$. Каждый участник $P_i$ получает соответствующую долю $sk_i$ и только её. Важно, что все участники знают публичный ключ $pk$, и ни один из участников не получает никакой дополнительной информации о $sk$.
		\item \label{def:Tsign} \emph{Протокол распределённой подписи (РП)}, в результате работы которого все участники получают сообщение и действуют совместно для выработки действующей подписи, проверяемой с помощью $pk$. Важно отметить, что для получения валидной подписи достаточно $t$ уникальных участников схемы.
	\end{itemize}

	Кроме того, могут быть реализованы следующие опциональные протоколы:

	\begin{itemize}
		\item \label{def:Tpredsign} \emph{Протокол выработки распределённой предподписи}, который является вспомогательным для выработки textit{распределённой подписи}. В результа-те его выполнения которого каждый участник получает т.н. \emph{личную предподпись}, которая не зависит от подписываемого сообщения. Выработанная \emph{предподпись} может быть использована на конкретном сообщении один раз во время выполенения протокола \emph{распределённой подписи (РП)}. Этот протокол является вспомогательным из-за того, изолирует взаимодействие между участниками не требующее подпи-сываемое сообщение.
		\item \label{def:Tredisp} \emph{Протокол перераспределения секрета}, который может быть совершён после \emph{протокола распределённой генерации ключа}. В результате работы этого протокола текущая \emph{$(t, n)$-пороговая схема} становится \emph{$(t’, n)$-пороговой схемой} $\left(t’ < n\right)$, а секретные доли $sk_i$ перераспределяются в секретные доли $sk’_i$.	
	\end{itemize}
	\end{defn}
	
	Стоит отметить, что данное выше определение также охватывает пороговые схемы, в которых протокол РГК происходит с помощью третьей стороны, которая после выработки валидной ключевой вары забывает секрет или в которых протокол РП подразумевает восстановление исходного приватного ключа $sk$. В дальнейшем мы рассмотрим как подобные «наивные» схемы распределённой подписи, так и схемы без доверия третьим лицам и отсутствием необходимости восстановления приватного ключа для создания валидной подписи.
	
	Прежде чем говорить о реализации пороговых схем, хочется понять, а возможно ли реализовать такую схему с максимальной степенью защиты, то есть с отсутствием доверия третьим сторонам. Для этого стоит обратиться к работам Эндрю Яо Цичжи, который доказал \cite{paper2}, что возможно создать протокол конфиденциального вычисления (англ. secure multi-party computation) и показал его реализацию. Сформулируем исходную задачу и дадим определения этого протокола.

	\begin{quote}
	\texttt{Пусть в конфиденциальном вычислении участвуют $N$ участников $p_1, p_2, \dots, p_N$. У каждого из участников есть секретные входные данные $d_1, d_2, \dots, d_N$. Участники хотят найти $F(d_1, d_2, \dots, d_N)$  без раскрытия секретных данных друг другу, где $F$ \--- известная всем участникам вычислимая функция от $N$ аргументов. }
	\end{quote}

	\begin{defn}\label{def:Tconf}	
	Алгоритм действий, выполняемый всеми N участниками для решения задачи выше, будем называть \emph{протоколом конфиденциального вычисления.}
	\end{defn}
	
	Также допускается, что среди участников будут \emph{получестные нарушители}, то есть те, которые верно следуют протоколу, но пытаются получить дополни-тельную информацию из любых промежуточных данных.
	
	В своей работе Яо предложил идею построения \emph{искажённой схемы} (англ. garbled circuit), который подразумевает, что выходная функция $F$ представляется в виде логической схемы, а секретные данные каждого участника представляются как входные данные функции $F$ в двоичном виде. Использование искажённой схемы подразумевает что участники шифруют исходную логическую схему функции $F$, и оперируют полученной искажённой схемой, подставляя в неё данные в зашифрованном виде. 
	
	Нетрудно понять, реализация пороговых схем с нулевым доверием опирается на уже решённую задачу конфиденциального вычисления. Таким образом, представленные в работе пороговые схемы с нулевым доверием являются более эффективными версиями решения этой задачи с точки зрения скорости вычисления.
	
	
	\section{Наивная схема}
	
	Для начала попробуем создать простую пороговую $(t,n)$-схему, которая позволяет $t$ участникам сгенерировать валидную подпись к сообщению. Пусть имеется схема ЭП и пусть имеется $(t, n)$-пороговая схема разделения секрета (например схема разделения секрета Шамира). Это означает, что любые $t$ участников могут восстановить некоторый общий секрет.
	
	Для \emph{распределённой генерации ключа \ref{def:Tkeygen}} пригласим дилера, то есть некоторое третье лицо, которое будет выполнять алгоритм создания валидной ключевой пары. После генерации открытого и закрытого ключа дилер должен разделить секрет в соответствии с правилами $(t, n)$-пороговой схемы разделения секрета. Раздав полученные доли секрета участникам, дилер должен забыть ранее сгенерированный закрытый ключ.
	
	Для \emph{выработки валидной подписи \ref{def:Tsign}} $t$ участников должны будут восстановить закрытый ключ, дальше любой из этих участников должен будет сгенерировать валидную подпись к сообщению и забыть закрытый ключ.
	
	Отметим недостатки этой схемы: 
	\begin{enumerate}[label=\arabic*)]
		\item для генерации ключевой пары привлекается третья сторона (\emph{дилер});
		\item закрытый ключ восстанавливается входе вычисления подписи;
		\item во время генерации подписи один или несколько участников имеют полный доступ к закрытому ключу;
	\end{enumerate}

	Несмотря на наивность этой схемы можно заметить, что пороговые схемы опираются на пороговые схемы разделения секрета. Существуют разные схемы разделения секрета, однако в дальнейшем мы будем использовать схему разделения секрета Шамира. В некоторых источниках используется схема VSS (verifiable secret sharing) или проверяемая схема разделения секрета, которая является улученной версией разделения секрета Шамира, и позволяет проверить, является ли та или иная доля секрета валидной (то есть позволяет бороться со злоумышленниками, которые пытаются выдать себя за владельца части подписи). Принцип схемы Шамира описан в приложении \ref{applic:Shamir}.
	
	
	\section{Схемы с нулевым доверием}
	
	Для более детального понимания принципов работы схем с нулевым доверием начнём рассматривать схему Эль-Гамаля в качестве схемы электронной подписи. Её описание может быть найдено в приложении \ref{applic:ElGam}. Основная проблема в преобразовании DSA в пороговый вариант \--- это вычисление значений R и s (смотри приложение \ref{applic:ElGam}), поскольку они требуют умножения и модульных обратных операций \cite{paper3}.
	
		\subsection{Генерация ключа}
		
		Прежде чем переходить к построению алгоритма распределённой генерации ключа стоит отметить аддитивную особенность схемы разделения секрета Шамира. Это означает, что имея доли $(x_1, y_1), \dots,  (x_n, y_n)$ и $(x_1, z_1), \dots,  (x_n, z_n)$ соответствующие секретам $y$ и $z$, доли $(x_1, y_1+z_1), \dots,  (x_n, y_n+z_n)$ будут соответствовать секрету $y+z$. С учётом аддитивного свойства открытого и закрытого ключа схемы Эль-Гамаля, данный факт легко описывает схему генерации ключа.


		\begin{algorithm}
			\caption{Алгоритм генерации ключа \\ (с позиции $i$-го участника)}
			\label{alg:Tgen}
	
			\KwData{Отсутсвует}
			\KwResult{Общий публичный ключ $pk$ и доля секретного ключа $sk^i$}
	
			\setlength{\parskip}{0.4\baselineskip}
	
			Вычислить валидную пару $sk_i$ и $pk_i$ \--- закрытый и открытый ключи схемы Эль-Гамаля \linebreak
			(стоит пояснить, что общий закрытый ключ схемы будет иметь вид $sk=sk_1+\dots+sk_n$).
			\\Раскрыть публичный ключ $pk_i$ остальным участникам и дождаться публичных ключей остальных участников
			\\Разделить секретный ключ $sk_i$ на доли $sk_i^1, \dots, sk_i^n$ по $(t,~n)$-схеме разделения Шамира \linebreak (стоит отметить, что обозначение $sk_i^m$ означает долю $(x_m, y_i^m)$,  то есть участники заранее договариваются о точках, в 	которых будут вычисляться значения многочленов в ходе вычисления долей секрета Шамира)
			\\Раздать долю $sk_i^m$ участнику под номером $m$ и поделать этот пункт для каждого $m=1\dots n$, после чего дождаться долей от остальных участников (к концу этого шага у $i$-го участника будут доли $sk_1^i, \dots, sk_n^i$)
			\\Сформировать свою долю секрета $sk^i=sk_1^i+\dots+sk_n^i$ (то есть итоговая доля секрета будет иметь вид $(x_i, y_1^i+\dots+y_n^i)$)
			\\Сформировать общий публичный как $pk=pk_1+\dots+pk_n$
			\\Вернуть общий публичный ключ $pk$ и свою долю секрета $sk^i$
	
		\end{algorithm}

		
		Из-за описанных свойств аддитивности по окончании работы алгоритма \ref{alg:Tgen}, описанного на странице \pageref{alg:Tgen}, произвольные $t$ участников смогут совместно восстановить общий закрытый ключ $sk$ (соответствующий общему публичному ключу $pk$) и сделать валидную подпись. 
		
		Стоит отметить, что в описанном выше алгоритме закрытый ключ $sk$ не раскрывается ни на одном этапе. Таким образом, для построения пороговой схемы с нулевым доверием необходимо описать алгоритм конфиденциального вычисления подписи без раскрытия долей секрета выше.
		
		
		\subsection{Генерация подписи}
		
		Как уже отмечалось ранее основная трудность в создании пороговой схемы из схемы Эль-Гамаля заключается умножении и модульных обратных операций, поскольку они не тривиальны для схемы разделения секрета Шамира. Чтобы преодолеть эту проблему, Дональд Бивер продемонстрировал \cite{paper4,paper5} протоколы умножения и обратной инверсии, которые опираются на мультипликативные тройки Бивера (англ. Beaver multiplicative triples). Это такие мультипликативные тройки чисел $(a, b, c)$, что $c=a\times b$, что они были получены с позиции участника без вычисления непосредственных значений $a, b, c$. Другими словами каждый участник генерирует у себя случайные доли $s_a, s_b, s_c$ секретов $a, b, c$ такие, что $c=a\times b$ и сами секреты $a, b, c$ не раскрываются ни на одном этапе. Варианты решение задачи гене-рации троек Бивера можно найти в \cite{paper6}
		
		Помимо описанных выше протоколов существуют другие, использующие свойства гомоморфной криптографии. Так, например, Дженнаро и Гольдфедер предложили \cite{paper7} протокол, который преобразует мультипликативные доли секрета в его аддитивные доли.
		
		Подробнее протоколы Бивера описаны в приложении \ref{applic:MultInv}, дальнейшее их описание будет происходить в виде вызовов функций $Mul(x, y)$ и $Invert(z)$. С точки зрения одного участника фраза «вычислить $m=Mul(x, y)$» будет обозначать, что у участника есть доли $x$ и $y$ секретов $X$ и $Y$ соответственно и этот участник (совместно с другими участниками) инициирует протокол Бивера для вычисления произведения $M$ секретов $X$ и $Y$ ($M=X\times Y$) после чего получает долю $m$ секрета $M$. Аналогично с функцией $Invert$. Важной особенностью протоколов Бивера является тот факт, что протоколы $Mul$ и $Invert$ не требуют в своей реализации раскрытия секретов, используемых в вычислениях.
		
		Продемонстрируем алгоритм \ref{alg:Tsign} пороговой подписи на странице \pageref{alg:Tsign}, описав его с позиции $i$-го участника. Будем считать у него имеется доля $sk_i$ секрета $sk$. Пусть задана циклическая группа $G$ с порядком $q$ (простое число) и генератором группы $g$. Пусть так же задана хеш-функции $H: \{0,1\}^* \rightarrow~\mathbb{Z}_q$ и $H': G \rightarrow \mathbb{Z}_q$
				
		\begin{algorithm}
			\caption{Алгоритм генерации подписи \\ (с позиции $i$-го участника)}
			\label{alg:Tsign}
			
			\KwData{Произвольное сообщение $M$ (представленное в виде бит)}
			\KwResult{Подпись входного сообщения}
			
			\setlength{\parskip}{0.4\baselineskip}
			
			Совместно с другими участниками вычислить долю $k_i$, случайного секрета $K$. Важно, чтобы участники сгенерировали секрет $K$ не раскрывая его значения (без дилера). \linebreak
			Это может быть сделано аналогично алгоритму \ref{alg:Tgen} распределённой генерации ключа. 
			\\Аналогично пункту 1 вычислить долю $w_i$ секрета $W$.
			\\Вычислить долю $d_i$ = $Mul(w_i, k_i)$ секрета $D=W\times K$
			\\Вычислить долю $u_i$ = $Mul(w_i, sk_i)$ секрета $U=W\times sk$
			\\Совместно с другими участниками восстановить значение $D$ по принципу $(t, n)$-пороговой схемы
			\\Вычислить $R_i=g^{w_i D^{-1}}\in G$, отправить $R_i$ другим участникам и дождаться сообщений других.
			\\Совместно с другими участниками восстановить значение~$R=g^{W D^{-1}}$. 
			Это может быть сделано по тому же принципу восстановления секрета, как и в исходной $(t, n)$-пороговой схеме. На примере разделения секрета Шамира можно заметить, что вид полинома не меняется при переходе к элементам циклической группы. Соответственно точки $R_i$ могут быть так же использованы в полиноме для восстановления секрета $R$.
			\\Вычислить $r = H’(R)$.
			\\Вычислить $s_i = H(M) \cdot k_i + r \cdot u_i$  \--- долю подписи $S$.
			\\Совместно с другими участниками восстановить значение $S$ по принципу $(t, n)$-пороговой схемы
			\\Вернуть пару $(r, S)$
			
		\end{algorithm}
		
		Представленный алгоритм можно разделить на две части. В пунктах 1-7 никак не используется подписываемое сообщение. Соответственно можно вынести эти пункты в отдельный протокол выработки предподписи.
		
		В итоге можно видеть, что была получена подпись сообщения без раскрытия закрытого ключа ни одной стороной. Проверка же полученной подписи происходит по обычным правилам проверки схемы Эль-Гамаля.
		


	\newpage
	\section*{ВЫВОДЫ}
	
	Рассмотренные вопросы построения пороговых схем на примере схемы Эль-Гамаля показали, что возможно достичь эффективного вычисления пороговой подписи с нулевым доверием. 
	
	Стоит сказать, что также возможно построить пороговые схемы и для дру-гих криптографических схем. Так, например в работе \cite{paper8} представлена RSA-пороговая схема без доверенного дилера. 
	
	На данный момент самой главной проблемой пороговых схем является эффективное вычисление произведения двух секретных значений на основе их долей без раскрытия самих секретов. Именно поэтому большей популярностью пользуются схемы с наименьшим числом мультипликативных операций, как например схема Эль-Гамаля.
	
	Аддитивное свойство алгоритмов разделения секретов, которые используются внутри протоколов выработки пороговой подписи, являются ещё одной причинной эффективного вычисления некоторых значений входе выработки подписи по схеме Эль-Гамаля. Вычисления получаются не только интуитивно понятными, но и не требуют дополнительных манипуляций.
	
	С практической точки зрения пороговые схемы позволяют выразить общее мнение некоторой группы лиц по тому или иному вопросу без непосредственного раскрытия лиц того большинства, которое проголосовало за это мнение. Наблюдая за стремлением мира криптовалют к межблокченовому взаимодействию, можно сказать, что всё больше систем будут использовать пороговые подписи в своей работе.
	
	
	\newpage
	\section*{ЗАКЛЮЧЕНИЕ}
	
	В рамках производственной практики на кафедре компьютерной безопасности перед студентом были описаны различные пороговые схемы, в том числе и на основе подписи Эль-Гамаля, и проанализирована их степень защищённости.
	
	Студент научился работать со схемами разделения секрета Шамира, VSS и др., изучил принципы работы традиционной подписи Эль-Гамаля, а также научился формировать пороговые подписи с нулевым доверием. 
	
	
	
	\newpage
	\printbibliography[title={БИБЛИОГРАФИЧЕСКИЙ СПИСОК}]
	
	\newpage
	\section*{ПРИЛОЖЕНИЯ}
	
	\stepcounter{section}
	\renewcommand\thesubsection{\Asbuk{subsection}}
		
		\subsection{Схема Шамира} \label{applic:Shamir}
		
		Опишем принцип разделения секрета Шамира. Он основан на том факте, что для интерполяции многочлена степени $k-1$ требуется $k$ точек. Каждую точку будем принимать за часть доли секрета. Таким образом никакие $k-1$ точек и меньше не смогут восстановить многочлен степени $k$, а следовательно, не смогут восстановить секрет. Более формально ниже.
		
		Пусть нужно разделить секрет $M$ между $n$ сторонами таким образом, чтобы любые $k$ участников могли бы восстановить секрет. Будем описывать алгоритм разделения секрета со стороны дилера. 
		
		Выберем некоторое простое число $p>M$, которое будет задавать размер конечного поля. Его можно открыто сообщать всем сторонам. Над этим полем построим многочлен степени $k-1$ вида
		
		\[ F(x) = M + a_1 x + a_2 x^2 + \dots + a_{k-1} x^{k-1} \pmod p, \]
		
		где $a_1, a_2, \dots, a_{k-1}$ \--- случайно выбранные коэффициенты, $M$ \--- разделяемый секрет. Дилер не должен разглашать коэффициенты многочлена. Особенность этого многочлена в том, что его значение в нуле равно заданному секрету.
		
		Для генерации долей секрета дилер должен вычислить значения построенного многочлена в $n$ различных точках отличных от нуля. Он может это сделать, например, следующим образом.
		
		\begin{gather*}
			x_1=1, y_1 = F(1) \\
			x_2=2, y_2 = F(2) \\
			\dots 			  \\
			x_n=n, y_n = F(n) \\
		\end{gather*}
		
		После чего дилер должен раздать секреты участникам, то есть $i$-ый участник получит пару $(x_i, y_i)$ как свою долю секрета. Коэффициенты многочлена и сам секрет дилером забываются.
		
		Для восстановления секрета $k$-участников должны обменяться своими секретами и вычислить интерполяционный многочлен Лагранжа и его значение в нуле. Построение этого много члена выглядит как:
		\begin{align*}
			F(z) &= \sum_{i=1}^{k} l_i(z) y_i \pmod p  \\
			l_i(z) &= \prod_{i\ne j} \frac{z-x_j}{x_i - x_j} \pmod p 
		\end{align*}
	
		Особенностью схемы является то, что вероятность раскрытия секрета в случае известных $k-1$ долей оценивается как $p^{-1}$. То есть в результате интерполяции по $k-1$ точке секретом может быть любой элемент поля с равной вероятностью. При этом попытка полного перебора всех возможных теней не позволит злоумышленникам получить дополнительную информацию о секрете.
		
		\subsection{Схема электронной подписи Эль-Гамаля} \label{applic:ElGam}
		
		Пусть задана циклическая группа $G$ с порядком $q$ (простое число) и генератором группы $g$. Пусть так же задана хеш-функции $H: \{0, 1\}^* \rightarrow \mathbb Z_q$ и $H’: G \rightarrow \mathbb Z_q$.
		
		\begin{itemize}
			\item Закрытым ключом является произвольное выбранное значение $x\in~\mathbb Z_q$
			\item Открытым ключом будет $y=g^x \in G$
		\end{itemize}

	

		\begin{algorithm}[H]
			\caption{Алгоритм подписи}
			\label{alg:EGsign}
			
			\KwData{Произвольное сообщение $M$ (представленное в виде бит)}
			\KwResult{Подпись входного сообщения}

			Вычислить $m=H(M)\in \mathbb Z_q$
			\\Выбрать случайное $k \in \mathbb Z_q$
			\\Вычислить $R=g^{k^{-1}} \in G$ и $r=H’(R) \in \mathbb Z_q$
			\\Вычислить $s=k(m + x\cdot r) \pmod q$
			\\Вернуть пару $(r, s)$
			
		\end{algorithm}		
	
		\begin{algorithm}[H]
			\caption{Алгоритм верификации}
			\label{alg:EGverify}
			\SetAlgoNoEnd \SetAlgoNoLine 
			
			\KwData{Проверяемое сообщение $M$, подпись $(r, s)$ и открытый ключ $y$}
			\KwResult{Результат проверки}
			
			Вычислить $R’= y^{r\cdot s^{-1}} \cdot g^{m\cdot s^{-1}} \in G$
			\\ \eIf{$H’(R’)=r$,}{вернуть, что подпись верна,}{отклонить её.}
						
		\end{algorithm}		
		
		
		\subsection{Умножение и инверсия секретов по их долям} \label{applic:MultInv}
		
		Пусть у нас есть доли $x_1, \dots, x_n$ секрета $X$ и $y_1, \dots, y_n$ секрета $Y$, полученные в результате работы некоторой аддитивной $(t, n)$-пороговой схемы разделения секрета. Перед участниками стоит задача получения долей секретов $Z=X\times Y$ и $V=X^{-1}$ без раскрытия изначальных секретов $X$ и $Y$. Описанные ниже алгоритмы будут проводиться с позиции $i$-го участника, который владеет долями $x_i$ и $y_i$.
		
		\begin{algorithm}
			\label{alg:Tmult}
			\caption{Алгоритм умножения $Mul$}

			
			\KwData{Доли $x_i$ и $y_i$ секретов $X$ и $Y$}
			\KwResult{Доля $z_i$ секрета $Z=X\times Y$}
			
			Совместно с другими участниками сгенерировать доли $a_i, b_i, c_i$ соответствующие тройке Бивера $A, B, C\ (C=A\times B)$
			\\Посчитать $d_i = x_i + a_i, e_i = y_i + b_i$ \linebreak
			По свойству аддитивности полученные значения будут долями секретов $D=X+A$ и $E=Y+B$ соответственно.
			\\Совместно с другими участниками восстановить значения $D$ и $E$ по принципу $(t, n)$-пороговой схемы.
			\\Посчитать $z_i = c_i + E\times x_i + D\times y_i - E\times D$. \linebreak
			По свойству аддитивности полученное значение будет долей секрета \linebreak 
			$C + E X + D Y - E D = A B + (Y+B) X + (X+A) Y - (Y+B) (X+A) = A B + X Y + X B + X Y + Y A - X Y - X B - Y A - A B = X\times Y = Z$.
			\\Вернуть $z_i$.
			
			
		\end{algorithm}	
		
		Стоит отметить, что на 2-м шаге алгоритма \ref{alg:Tmult} происходит реконструирование значений $D$ и $E$, что может показаться небезопасным. Однако поскольку ни один из секретов $X, Y, A$ и $B$ не был реконструирован, то и раскрытие $D$ и $E$ не даёт никакой информации об исходных секретах.
		
		\begin{algorithm}
			\caption{Алгоритм инверсии $Invert$}
			\label{alg:Tinv}
			
			\KwData{Доля $x_i$ секрета $X$}
			\KwResult{Доля $v_i$ секрета $V=X^{-1}$}
			
			
			Совместно с другими участниками вычислить долю $a_i$, случайного секрета $A$. Важно, чтобы участники сгенерировали секрет $A$ не раскрывая его значения (без дилера).
			Это может быть сделано аналогично алгоритму \ref{alg:Tgen} распределённой генерации ключа. 
			\\Вычислить долю $w_i = Mul(a_i, x_i)$, секрета $W=A\times X$.
			\\Совместно с другими участниками восстановить значение $W$ по принципу $(t, n)$-пороговой схемы 
			\\Вычислить $v_i$ = $W^{-1}\times a_i$. \linebreak
			По свойству аддитивности полученное значение будет долей секрета 
			$W^{-1} A = (A X)^{-1}A = A^{-1} X^{-1} A = X^{-1} = V$
			\\Вернуть $v_i$.
			
			
		\end{algorithm}	
	
	
\end{document} % Конец текста.